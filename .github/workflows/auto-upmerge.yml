name: Auto Upmerge

on:
  pull_request:
    types: [closed]
    branches:
      - "candidate-*"

jobs:
  auto-upmerge:
    # Only run if PR was merged (not just closed)
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: "Debug Info"
        env:
          PULL_REQUEST_NUMBER: ${{ github.event.pull_request.number }}
          PULL_REQUEST_TITLE: ${{ github.event.pull_request.title }}
          PULL_REQUEST_AUTHOR: ${{ github.event.pull_request.user.login }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
          MERGE_COMMIT_SHA: ${{ github.event.pull_request.merge_commit_sha }}
        run: |
          echo "Pull Request Number: $PULL_REQUEST_NUMBER"
          echo "Pull Request Title: $PULL_REQUEST_TITLE"
          echo "Pull Request Author: $PULL_REQUEST_AUTHOR"
          echo "Base Branch: $BASE_BRANCH"
          echo "Merge Commit SHA: $MERGE_COMMIT_SHA"

      - name: "Setup Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.8"

      - name: "Install Dependencies"
        run: |
          set -xe
          python -VV
          python -m site
          python -m pip install --upgrade pip setuptools wheel

      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0
          fetch-tags: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Configure Git User"
        run: |
          git config user.name "HPCC4J Bot"
          git config user.email "support@hpccsystems.com"

      - name: "Perform Upmerge"
        env:
          PULL_REQUEST_NUMBER: ${{ github.event.pull_request.number }}
          PULL_REQUEST_TITLE: ${{ github.event.pull_request.title }}
          PULL_REQUEST_AUTHOR: ${{ github.event.pull_request.user.login }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
          MERGE_COMMIT_SHA: ${{ github.event.pull_request.merge_commit_sha }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PROJECT_CONFIG: ${{ vars.PROJECT_CONFIG }}
        shell: python
        run: |
          import os
          import re
          import subprocess
          import sys
          import json
          import time

          def extractVersion(versionStr):
              parts = versionStr.split('.')
              if len(parts) != 3:
                  print(f'Invalid version: {versionStr}')
                  sys.exit(1)
              if parts[2].lower() == 'x':
                  parts[2] = '0'

              major, minor, point = map(int, parts)
              return [major, minor, point]

          def getTagVersionForCmd(cmd):
              versionPattern = re.compile(r".*[^0-9]+([0-9]+\.[0-9]+\.[0-9]+).*")

              # Get latest release version
              gitTagProcess = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
              (output, err) = gitTagProcess.communicate()
              gitTagProcessStatus = gitTagProcess.wait()

              if gitTagProcessStatus != 0:
                  print('Unable to retrieve latest git tag.')
                  sys.exit(1)

              latestGitTag = str(output)

              versionMatch = versionPattern.match(latestGitTag)
              if versionMatch:
                  return extractVersion(versionMatch.group(1))
              else:
                  print(f'Unable to extract version from git tag: {latestGitTag} expected string format: <prefix>major.minor.point(-patch)?<postfix>')
                  sys.exit(2)

          def buildBranchString(version):
              major, minor, point = map(int, version)
              return f"candidate-{major}.{minor}.x"

          def createReleaseTagPattern(projectConfig, major=None, minor=None, point=None):
              releaseTagPrefix = projectConfig.get('tagPrefix')
              releaseTagPostfix = projectConfig.get('tagPostfix')

              if releaseTagPrefix is None or releaseTagPostfix is None:
                  print('Error: PROJECT_CONFIG is missing required fields: tagPrefix and/or tagPostfix')
                  sys.exit(1)

              releaseTagPattern = releaseTagPrefix
              if major is not None:
                  releaseTagPattern += str(major) + '\\.'
              else:
                  releaseTagPattern += '[0-9]+\\.'

              if minor is not None:
                  releaseTagPattern += str(minor) + '\\.'
              else:
                  releaseTagPattern += '[0-9]+\\.'

              if point is not None:
                  releaseTagPattern += str(point) + '(-[0-9]+)?'
              else:
                  releaseTagPattern += '[0-9]+(-[0-9]+)?'

              releaseTagPattern += releaseTagPostfix + '$'

              return releaseTagPattern

          def getLatestSemVer(projectConfig, major=None, minor=None, point=None):
              cmd = "git tag --list --sort=-v:refname | grep -E '" + createReleaseTagPattern(projectConfig, major, minor, point) + "' | head -n 1"
              return getTagVersionForCmd(cmd)

          def generateUpMergeBranchList(projectConfig, branchName):
              latestVersion = getLatestSemVer(projectConfig)

              versions = []
              if branchName == "master":
                  return versions
              else:
                  # Extract candidate branch major / minor version
                  candidateBranchPattern = re.compile(r"candidate-([0-9]+\.[0-9]+\.([0-9]+|x)).*")
                  branchVersionMatch = candidateBranchPattern.match(branchName)
                  if not branchVersionMatch:
                      print(f'Branch {branchName} does not match expected pattern')
                      sys.exit(1)
                  
                  branchVersion = extractVersion(branchVersionMatch.group(1))

                  # Get latest release in branch
                  latestBranchVer = getLatestSemVer(projectConfig, branchVersion[0], branchVersion[1])

                  curMajor = branchVersion[0]
                  latestMajor = latestVersion[0]
                  while curMajor <= latestMajor:
                      latestVersionInMajor = getLatestSemVer(projectConfig, curMajor)

                      curMinor = 0
                      if curMajor == branchVersion[0]:
                          curMinor = branchVersion[1]

                      latestMinor = latestVersionInMajor[1]

                      while curMinor <= latestMinor:
                          latestPointInMinor = getLatestSemVer(projectConfig, curMajor, curMinor)
                          versions.append(buildBranchString([latestPointInMinor[0], latestPointInMinor[1], latestPointInMinor[2] + 2]))
                          curMinor += 2
                      curMajor += 1

              return versions

          def getTargetInBranchVersion(targetBranch):
              # Use git show to get the version from the top-level pom.xml
              cmd = ["git", "show", f"origin/{targetBranch}:pom.xml"]
              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              pom_content = result.stdout

              version_pattern = re.compile(r'<version>(\s*[0-9]+\.[0-9]+\.[0-9]+(-[0-9]+)?(-SNAPSHOT)?\s*)</version>')
              match = version_pattern.search(pom_content)
              if match:
                  return match.group(1).strip()
              else:
                  print(f"Error: Unable to find version in pom.xml for branch {targetBranch}")
                  sys.exit(1)

          def upmerge_to_branch(source_branch, target_branch, pr_number, pr_title):
              print(f"\n{'='*60}")
              print(f"Upmerging {source_branch} to {target_branch}")
              print(f"{'='*60}\n")
              
              # Fetch latest changes
              subprocess.run(["git", "fetch", "origin"], check=True)
              
              # Checkout target branch
              print(f"Checking out {target_branch}...")
              result = subprocess.run(["git", "checkout", target_branch], capture_output=True, text=True)
              if result.returncode != 0:
                  print(f"Failed to checkout {target_branch}: {result.stderr}")
                  return False
              
              # Update to latest
              print(f"Updating {target_branch} to latest from origin...")
              result = subprocess.run(["git", "merge", f"origin/{target_branch}", "--ff-only"], capture_output=True, text=True)
              if result.returncode != 0:
                  print(f"Failed to fast-forward {target_branch}: {result.stderr}")
                  return False
              
              # Get target branch version before merge
              target_version = getTargetInBranchVersion(target_branch)
              print(f"Target branch version: {target_version}")
              
              # Merge source branch
              print(f"Merging origin/{source_branch}...")
              merge_msg = f"Merge {source_branch} to {target_branch}\n\nAuto-upmerge from PR #{pr_number}: {pr_title}"
              result = subprocess.run(
                  ["git", "merge", f"origin/{source_branch}", "--no-commit"],
                  capture_output=True, text=True
              )
              
              # Check for conflicts
              conflict_check = subprocess.run(
                  ["git", "ls-files", "-u"],
                  capture_output=True, text=True
              )
              conflict_count = len(conflict_check.stdout.strip().split('\n')) if conflict_check.stdout.strip() else 0
              
              if conflict_count > 0:
                  print(f"‚ùå Conflicts detected during upmerge to {target_branch}")
                  print("Aborting merge...")
                  subprocess.run(["git", "merge", "--abort"], capture_output=True)
                  return False
              
              # Update Maven version to target branch version after merge
              # This preserves any pom.xml changes (dependencies, etc.) while maintaining correct version
              print(f"Updating Maven version to {target_version}...")
              mvn_result = subprocess.run(
                  ["mvn", "versions:set", f"-DnewVersion={target_version}", "-DgenerateBackupPoms=false"],
                  capture_output=True, text=True
              )
              if mvn_result.returncode != 0:
                  print(f"Failed to update Maven versions: {mvn_result.stderr}")
                  subprocess.run(["git", "merge", "--abort"], capture_output=True)
                  return False
              
              # Stage the pom.xml version changes
              subprocess.run(["git", "add", "pom.xml", "**/pom.xml"], capture_output=True)
              
              # Commit the merge
              print("Committing merge...")
              result = subprocess.run(
                  ["git", "commit", "-s", "-m", merge_msg],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"Failed to commit: {result.stderr}")
                  return False
              
              # Push to origin
              print(f"Pushing to origin/{target_branch}...")
              result = subprocess.run(
                  ["git", "push", "origin", target_branch],
                  capture_output=True, text=True
              )
              if result.returncode != 0:
                  print(f"Failed to push: {result.stderr}")
                  return False
              
              print(f"‚úÖ Successfully upmerged to {target_branch}")
              return True

          # Main execution
          pr_number = os.environ['PULL_REQUEST_NUMBER']
          pr_title = os.environ['PULL_REQUEST_TITLE']
          base_branch = os.environ['BASE_BRANCH']
          
          # Get project config from environment variable or use default
          projectConfigJson = os.environ.get('PROJECT_CONFIG')
          if projectConfigJson:
              projectConfig = json.loads(projectConfigJson)
          else:
              # Fallback to hardcoded config if environment variable is not set
              print("Warning: PROJECT_CONFIG environment variable not set, using default configuration")
              projectConfig = {
                  "projectName": "HPCC4J",
                  "projectPrefixes": ["HPCC4J"],
                  "tagPrefix": "hpcc4j_",
                  "tagPostfix": "-release"
              }
          
          if not isinstance(projectConfig, dict):
              print('Error: PROJECT_CONFIG is not a valid JSON object, aborting.')
              sys.exit(1)
          
          if 'tagPrefix' not in projectConfig or 'tagPostfix' not in projectConfig:
              print('Error: PROJECT_CONFIG is missing required fields: tagPrefix and/or tagPostfix')
              sys.exit(1)
          
          print(f"Starting auto-upmerge for PR #{pr_number}: {pr_title}")
          print(f"Base branch: {base_branch}")
          
          # Generate list of target branches
          target_branches = generateUpMergeBranchList(projectConfig, base_branch)
          target_branches.append("master")
          
          print(f"\nTarget branches for upmerge: {target_branches}")
          
          # Track results
          successful_upmerges = []
          failed_upmerges = []
          skipped_upmerges = []
          
          # Perform upmerges
          for target_branch in target_branches:
              try:
                  success = upmerge_to_branch(base_branch, target_branch, pr_number, pr_title)
                  if success:
                      successful_upmerges.append(target_branch)
                  else:
                      failed_upmerges.append(target_branch)
              except Exception as e:
                  print(f"Exception during upmerge to {target_branch}: {e}")
                  failed_upmerges.append(target_branch)
          
          # Create summary
          print("\n" + "="*60)
          print("UPMERGE SUMMARY")
          print("="*60)
          print(f"\n‚úÖ Successful upmerges ({len(successful_upmerges)}):")
          for branch in successful_upmerges:
              print(f"  - {branch}")
          
          if failed_upmerges:
              print(f"\n‚ùå Failed upmerges ({len(failed_upmerges)}):")
              for branch in failed_upmerges:
                  print(f"  - {branch}")
          
          # Save results for reporting
          results = {
              "pr_number": pr_number,
              "pr_title": pr_title,
              "base_branch": base_branch,
              "successful_upmerges": successful_upmerges,
              "failed_upmerges": failed_upmerges,
              "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
          }
          
          with open('upmerge-results.json', 'w') as f:
              json.dump(results, f, indent=2)
          
          # Exit with error if any upmerges failed
          if failed_upmerges:
              print("\n‚ö†Ô∏è  Some upmerges failed. Manual intervention may be required.")
              sys.exit(1)
          else:
              print("\n‚úÖ All upmerges completed successfully!")

      - name: "Upload Upmerge Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: upmerge-results-pr-${{ github.event.pull_request.number }}
          path: upmerge-results.json
          retention-days: 30

      - name: "Post Comment on Failure"
        if: failure()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        shell: python
        run: |
          import os
          import json
          import subprocess
          from pathlib import Path
          
          pr_number = os.environ['PR_NUMBER']
          
          # Try to load results if they exist
          results_file = Path('upmerge-results.json')
          if results_file.exists():
              with open(results_file, 'r') as f:
                  results = json.load(f)
              
              failed_branches = results.get('failed_upmerges', [])
              successful_branches = results.get('successful_upmerges', [])
              
              comment = "## üîÑ Auto-Upmerge Results\n\n"
              comment += "**Status**: ‚ö†Ô∏è Some upmerges failed\n\n"
              
              if successful_branches:
                  comment += f"### ‚úÖ Successful Upmerges ({len(successful_branches)})\n\n"
                  for branch in successful_branches:
                      comment += f"- `{branch}`\n"
                  comment += "\n"
              
              if failed_branches:
                  comment += f"### ‚ùå Failed Upmerges ({len(failed_branches)})\n\n"
                  for branch in failed_branches:
                      comment += f"- `{branch}`\n"
                  comment += "\n"
                  comment += "**Action Required**: These branches need manual upmerging due to conflicts.\n"
              
              comment += "\n*This comment was automatically generated by the auto-upmerge workflow.*"
          else:
              comment = "## üîÑ Auto-Upmerge Results\n\n"
              comment += "**Status**: ‚ùå Upmerge process failed\n\n"
              comment += "The auto-upmerge workflow encountered an error. Please check the workflow logs for details.\n\n"
              comment += "*This comment was automatically generated by the auto-upmerge workflow.*"
          
          # Post comment
          comments_url = f'https://api.github.com/repos/{os.environ["GITHUB_REPOSITORY"]}/issues/{pr_number}/comments'
          comment_json = json.dumps(comment)
          
          subprocess.run([
              'curl', '-X', 'POST', comments_url,
              '-H', 'Content-Type: application/json',
              '-H', f'Authorization: token {os.environ["GITHUB_TOKEN"]}',
              '--data', f'{{"body": {comment_json}}}'
          ], check=True)

      - name: "Post Success Comment"
        if: success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        shell: python
        run: |
          import os
          import json
          import subprocess
          from pathlib import Path
          
          pr_number = os.environ['PR_NUMBER']
          
          # Load results
          results_file = Path('upmerge-results.json')
          if results_file.exists():
              with open(results_file, 'r') as f:
                  results = json.load(f)
              
              successful_branches = results.get('successful_upmerges', [])
              
              comment = "## üîÑ Auto-Upmerge Results\n\n"
              comment += "**Status**: ‚úÖ All upmerges successful\n\n"
              
              if successful_branches:
                  comment += f"### Upmerged Branches ({len(successful_branches)})\n\n"
                  for branch in successful_branches:
                      comment += f"- `{branch}`\n"
              
              comment += "\n*This comment was automatically generated by the auto-upmerge workflow.*"
              
              # Post comment
              comments_url = f'https://api.github.com/repos/{os.environ["GITHUB_REPOSITORY"]}/issues/{pr_number}/comments'
              comment_json = json.dumps(comment)
              
              subprocess.run([
                  'curl', '-X', 'POST', comments_url,
                  '-H', 'Content-Type: application/json',
                  '-H', f'Authorization: token {os.environ["GITHUB_TOKEN"]}',
                  '--data', f'{{"body": {comment_json}}}'
              ], check=True)
